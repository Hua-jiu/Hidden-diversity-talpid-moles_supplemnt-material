combined_counts$Var1 <- factor(combined_counts$Var1, levels = reordered_levels)
# 使用色盲友好的颜色组合
cbPalette <- c("#009E73", "#D55E00", "#F0E442", "#CC79A7", "#000000", "#56B4E9", "#E69F00", "#0072B2")
# 计算每个组合形式的总数
total_counts <- combined_counts %>%
group_by(Var1) %>%
summarise(total = sum(Freq))
# 绘制堆叠柱状图，以类别为柱，并展示每个类别中鉴定正确和错误的比例
p <- ggplot(combined_counts, aes(x = Var1, y = Freq, fill = consequence)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Correct" = "#009E73", "Incorrect" = "#D55E00")) +
labs(title = "Total Number of Correct and Incorrect Identifications by Combination",
x = "Combination",
y = "Total Number",
fill = "Identification Result") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
geom_text(data = total_counts, aes(x = Var1, y = total, label = paste("n =", total)),
vjust = -0.5, size = 3, inherit.aes = FALSE)
# 使用 ggbreak 包截断 y 轴
p
file_path <- "/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/R/2024-11-17 R语言绘图/docs/cross_valid_broken.xlsx"
data1 <- read_excel(file_path, sheet = "data1")
data2 <- read_excel(file_path, sheet = "data2")
data3 <- read_excel(file_path, sheet = "data3")
data4 <- read_excel(file_path, sheet = "data4")
data5 <- read_excel(file_path, sheet = "data5")
data <- data1
# 确保 consequence 和 wholeness 列是因子类型
data$consequence <- as.factor(data$consequence)
data$wholeness <- as.factor(data$wholeness)
# 创建一个新的列来表示组合形式，并将“+”改为“( )”
data$combination <- paste(data$dimension_have, "photos (", data$broken_num, "broken)")
# 将数据分为鉴定正确和鉴定错误的两组
correct_data <- subset(data, consequence == "True")
incorrect_data <- subset(data, consequence == "False")
# 统计每种组合形式的频数
correct_counts <- as.data.frame(table(correct_data$combination))
incorrect_counts <- as.data.frame(table(incorrect_data$combination))
# 添加一个列来标记数据是鉴定正确还是鉴定错误
correct_counts$consequence <- "Correct"
incorrect_counts$consequence <- "Incorrect"
# 合并两组数据
combined_counts <- rbind(correct_counts, incorrect_counts)
# 输出 levels(combined_counts$Var1) 到一个变量
levels_var1 <- levels(combined_counts$Var1)
# 变量按照 重新排序
reordered_levels <- levels_var1[rev(c(1,3,2,6,5,4,10,9,8,7))]
# 将 Var1 的因子水平设置为重新排序后的顺序
combined_counts$Var1 <- factor(combined_counts$Var1, levels = reordered_levels)
# 使用色盲友好的颜色组合
cbPalette <- c("#009E73", "#D55E00", "#F0E442", "#CC79A7", "#000000", "#56B4E9", "#E69F00", "#0072B2")
# 计算每个组合形式的总数
total_counts <- combined_counts %>%
group_by(Var1) %>%
summarise(total = sum(Freq))
# 绘制堆叠柱状图，以类别为柱，并展示每个类别中鉴定正确和错误的比例
p <- ggplot(combined_counts, aes(x = Var1, y = Freq, fill = consequence)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Correct" = "#009E73", "Incorrect" = "#D55E00")) +
labs(title = "Data1 Number of Correct and Incorrect Identifications by Combination",
x = "Combination",
y = "Total Number",
fill = "Identification Result") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
geom_text(data = total_counts, aes(x = Var1, y = total, label = paste("n =", total)),
vjust = -0.5, size = 3, inherit.aes = FALSE)
# 使用 ggbreak 包截断 y 轴
p
file_path <- "/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/R/2024-11-17 R语言绘图/docs/cross_valid_broken.xlsx"
data1 <- read_excel(file_path, sheet = "data1")
data2 <- read_excel(file_path, sheet = "data2")
data3 <- read_excel(file_path, sheet = "data3")
data4 <- read_excel(file_path, sheet = "data4")
data5 <- read_excel(file_path, sheet = "data5")
data <- data2
# 确保 consequence 和 wholeness 列是因子类型
data$consequence <- as.factor(data$consequence)
data$wholeness <- as.factor(data$wholeness)
# 创建一个新的列来表示组合形式，并将“+”改为“( )”
data$combination <- paste(data$dimension_have, "photos (", data$broken_num, "broken)")
# 将数据分为鉴定正确和鉴定错误的两组
correct_data <- subset(data, consequence == "True")
incorrect_data <- subset(data, consequence == "False")
# 统计每种组合形式的频数
correct_counts <- as.data.frame(table(correct_data$combination))
incorrect_counts <- as.data.frame(table(incorrect_data$combination))
# 添加一个列来标记数据是鉴定正确还是鉴定错误
correct_counts$consequence <- "Correct"
incorrect_counts$consequence <- "Incorrect"
# 合并两组数据
combined_counts <- rbind(correct_counts, incorrect_counts)
# 输出 levels(combined_counts$Var1) 到一个变量
levels_var1 <- levels(combined_counts$Var1)
# 变量按照 重新排序
reordered_levels <- levels_var1[rev(c(1,3,2,6,5,4,10,9,8,7))]
# 将 Var1 的因子水平设置为重新排序后的顺序
combined_counts$Var1 <- factor(combined_counts$Var1, levels = reordered_levels)
# 使用色盲友好的颜色组合
cbPalette <- c("#009E73", "#D55E00", "#F0E442", "#CC79A7", "#000000", "#56B4E9", "#E69F00", "#0072B2")
# 计算每个组合形式的总数
total_counts <- combined_counts %>%
group_by(Var1) %>%
summarise(total = sum(Freq))
# 绘制堆叠柱状图，以类别为柱，并展示每个类别中鉴定正确和错误的比例
p <- ggplot(combined_counts, aes(x = Var1, y = Freq, fill = consequence)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Correct" = "#009E73", "Incorrect" = "#D55E00")) +
labs(title = "Data2 Number of Correct and Incorrect Identifications by Combination",
x = "Combination",
y = "Total Number",
fill = "Identification Result") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
geom_text(data = total_counts, aes(x = Var1, y = total, label = paste("n =", total)),
vjust = -0.5, size = 3, inherit.aes = FALSE)
# 使用 ggbreak 包截断 y 轴
p
file_path <- "/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/R/2024-11-17 R语言绘图/docs/cross_valid_broken.xlsx"
data1 <- read_excel(file_path, sheet = "data1")
data2 <- read_excel(file_path, sheet = "data2")
data3 <- read_excel(file_path, sheet = "data3")
data4 <- read_excel(file_path, sheet = "data4")
data5 <- read_excel(file_path, sheet = "data5")
data <- data3
# 确保 consequence 和 wholeness 列是因子类型
data$consequence <- as.factor(data$consequence)
data$wholeness <- as.factor(data$wholeness)
# 创建一个新的列来表示组合形式，并将“+”改为“( )”
data$combination <- paste(data$dimension_have, "photos (", data$broken_num, "broken)")
# 将数据分为鉴定正确和鉴定错误的两组
correct_data <- subset(data, consequence == "True")
incorrect_data <- subset(data, consequence == "False")
# 统计每种组合形式的频数
correct_counts <- as.data.frame(table(correct_data$combination))
incorrect_counts <- as.data.frame(table(incorrect_data$combination))
# 添加一个列来标记数据是鉴定正确还是鉴定错误
correct_counts$consequence <- "Correct"
incorrect_counts$consequence <- "Incorrect"
# 合并两组数据
combined_counts <- rbind(correct_counts, incorrect_counts)
# 输出 levels(combined_counts$Var1) 到一个变量
levels_var1 <- levels(combined_counts$Var1)
# 变量按照 重新排序
reordered_levels <- levels_var1[rev(c(1,3,2,6,5,4,10,9,8,7))]
# 将 Var1 的因子水平设置为重新排序后的顺序
combined_counts$Var1 <- factor(combined_counts$Var1, levels = reordered_levels)
# 使用色盲友好的颜色组合
cbPalette <- c("#009E73", "#D55E00", "#F0E442", "#CC79A7", "#000000", "#56B4E9", "#E69F00", "#0072B2")
# 计算每个组合形式的总数
total_counts <- combined_counts %>%
group_by(Var1) %>%
summarise(total = sum(Freq))
# 绘制堆叠柱状图，以类别为柱，并展示每个类别中鉴定正确和错误的比例
p <- ggplot(combined_counts, aes(x = Var1, y = Freq, fill = consequence)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Correct" = "#009E73", "Incorrect" = "#D55E00")) +
labs(title = "Data3 Number of Correct and Incorrect Identifications by Combination",
x = "Combination",
y = "Total Number",
fill = "Identification Result") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
geom_text(data = total_counts, aes(x = Var1, y = total, label = paste("n =", total)),
vjust = -0.5, size = 3, inherit.aes = FALSE)
# 使用 ggbreak 包截断 y 轴
p
file_path <- "/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/R/2024-11-17 R语言绘图/docs/cross_valid_broken.xlsx"
data1 <- read_excel(file_path, sheet = "data1")
data2 <- read_excel(file_path, sheet = "data2")
data3 <- read_excel(file_path, sheet = "data3")
data4 <- read_excel(file_path, sheet = "data4")
data5 <- read_excel(file_path, sheet = "data5")
data <- data4
# 确保 consequence 和 wholeness 列是因子类型
data$consequence <- as.factor(data$consequence)
data$wholeness <- as.factor(data$wholeness)
# 创建一个新的列来表示组合形式，并将“+”改为“( )”
data$combination <- paste(data$dimension_have, "photos (", data$broken_num, "broken)")
# 将数据分为鉴定正确和鉴定错误的两组
correct_data <- subset(data, consequence == "True")
incorrect_data <- subset(data, consequence == "False")
# 统计每种组合形式的频数
correct_counts <- as.data.frame(table(correct_data$combination))
incorrect_counts <- as.data.frame(table(incorrect_data$combination))
# 添加一个列来标记数据是鉴定正确还是鉴定错误
correct_counts$consequence <- "Correct"
incorrect_counts$consequence <- "Incorrect"
# 合并两组数据
combined_counts <- rbind(correct_counts, incorrect_counts)
# 输出 levels(combined_counts$Var1) 到一个变量
levels_var1 <- levels(combined_counts$Var1)
# 变量按照 重新排序
reordered_levels <- levels_var1[rev(c(1,3,2,6,5,4,10,9,8,7))]
# 将 Var1 的因子水平设置为重新排序后的顺序
combined_counts$Var1 <- factor(combined_counts$Var1, levels = reordered_levels)
# 使用色盲友好的颜色组合
cbPalette <- c("#009E73", "#D55E00", "#F0E442", "#CC79A7", "#000000", "#56B4E9", "#E69F00", "#0072B2")
# 计算每个组合形式的总数
total_counts <- combined_counts %>%
group_by(Var1) %>%
summarise(total = sum(Freq))
# 绘制堆叠柱状图，以类别为柱，并展示每个类别中鉴定正确和错误的比例
p <- ggplot(combined_counts, aes(x = Var1, y = Freq, fill = consequence)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Correct" = "#009E73", "Incorrect" = "#D55E00")) +
labs(title = "Data4 Number of Correct and Incorrect Identifications by Combination",
x = "Combination",
y = "Total Number",
fill = "Identification Result") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
geom_text(data = total_counts, aes(x = Var1, y = total, label = paste("n =", total)),
vjust = -0.5, size = 3, inherit.aes = FALSE)
# 使用 ggbreak 包截断 y 轴
p
file_path <- "/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/R/2024-11-17 R语言绘图/docs/cross_valid_broken.xlsx"
data1 <- read_excel(file_path, sheet = "data1")
data2 <- read_excel(file_path, sheet = "data2")
data3 <- read_excel(file_path, sheet = "data3")
data4 <- read_excel(file_path, sheet = "data4")
data5 <- read_excel(file_path, sheet = "data5")
data <- data5
# 确保 consequence 和 wholeness 列是因子类型
data$consequence <- as.factor(data$consequence)
data$wholeness <- as.factor(data$wholeness)
# 创建一个新的列来表示组合形式，并将“+”改为“( )”
data$combination <- paste(data$dimension_have, "photos (", data$broken_num, "broken)")
# 将数据分为鉴定正确和鉴定错误的两组
correct_data <- subset(data, consequence == "True")
incorrect_data <- subset(data, consequence == "False")
# 统计每种组合形式的频数
correct_counts <- as.data.frame(table(correct_data$combination))
incorrect_counts <- as.data.frame(table(incorrect_data$combination))
# 添加一个列来标记数据是鉴定正确还是鉴定错误
correct_counts$consequence <- "Correct"
incorrect_counts$consequence <- "Incorrect"
# 合并两组数据
combined_counts <- rbind(correct_counts, incorrect_counts)
# 输出 levels(combined_counts$Var1) 到一个变量
levels_var1 <- levels(combined_counts$Var1)
# 变量按照 重新排序
reordered_levels <- levels_var1[rev(c(1,3,2,6,5,4,10,9,8,7))]
# 将 Var1 的因子水平设置为重新排序后的顺序
combined_counts$Var1 <- factor(combined_counts$Var1, levels = reordered_levels)
# 使用色盲友好的颜色组合
cbPalette <- c("#009E73", "#D55E00", "#F0E442", "#CC79A7", "#000000", "#56B4E9", "#E69F00", "#0072B2")
# 计算每个组合形式的总数
total_counts <- combined_counts %>%
group_by(Var1) %>%
summarise(total = sum(Freq))
# 绘制堆叠柱状图，以类别为柱，并展示每个类别中鉴定正确和错误的比例
p <- ggplot(combined_counts, aes(x = Var1, y = Freq, fill = consequence)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Correct" = "#009E73", "Incorrect" = "#D55E00")) +
labs(title = "Data5 Number of Correct and Incorrect Identifications by Combination",
x = "Combination",
y = "Total Number",
fill = "Identification Result") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
geom_text(data = total_counts, aes(x = Var1, y = total, label = paste("n =", total)),
vjust = -0.5, size = 3, inherit.aes = FALSE)
# 使用 ggbreak 包截断 y 轴
p
file_path <- "/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/R/2024-11-17 R语言绘图/docs/cross_valid_broken.xlsx"
data1 <- read_excel(file_path, sheet = "data1")
data2 <- read_excel(file_path, sheet = "data2")
data3 <- read_excel(file_path, sheet = "data3")
data4 <- read_excel(file_path, sheet = "data4")
data5 <- read_excel(file_path, sheet = "data5")
data <- data5
# 确保 consequence 和 wholeness 列是因子类型
data$consequence <- as.factor(data$consequence)
data$wholeness <- as.factor(data$wholeness)
# 创建一个新的列来表示组合形式，并将“+”改为“( )”
data$combination <- paste(data$dimension_have, "photos (", data$broken_num, "broken)")
# 将数据分为鉴定正确和鉴定错误的两组
correct_data <- subset(data, consequence == "True")
incorrect_data <- subset(data, consequence == "False")
# 统计每种组合形式的频数
correct_counts <- as.data.frame(table(correct_data$combination))
incorrect_counts <- as.data.frame(table(incorrect_data$combination))
# 添加一个列来标记数据是鉴定正确还是鉴定错误
correct_counts$consequence <- "Correct"
incorrect_counts$consequence <- "Incorrect"
# 合并两组数据
combined_counts <- rbind(correct_counts, incorrect_counts)
# 输出 levels(combined_counts$Var1) 到一个变量
levels_var1 <- levels(combined_counts$Var1)
# 变量按照 重新排序
reordered_levels <- levels_var1[rev(c(1,3,2,6,5,4,10,9,8,7))]
# 将 Var1 的因子水平设置为重新排序后的顺序
combined_counts$Var1 <- factor(combined_counts$Var1, levels = reordered_levels)
# 使用色盲友好的颜色组合
cbPalette <- c("#009E73", "#D55E00", "#F0E442", "#CC79A7", "#000000", "#56B4E9", "#E69F00", "#0072B2")
# 计算每个组合形式的总数
total_counts <- combined_counts %>%
group_by(Var1) %>%
summarise(total = sum(Freq))
# 绘制堆叠柱状图，以类别为柱，并展示每个类别中鉴定正确和错误的比例
p <- ggplot(combined_counts, aes(x = Var1, y = Freq, fill = consequence)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_manual(values = c("Correct" = "#009E73", "Incorrect" = "#D55E00")) +
labs(title = "Data5 Number of Correct and Incorrect Identifications by Combination",
x = "Combination",
y = "Total Number",
fill = "Identification Result") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
geom_text(data = total_counts, aes(x = Var1, y = total, label = paste("n =", total)),
vjust = -0.5, size = 3, inherit.aes = FALSE)
# 使用 ggbreak 包截断 y 轴
p
# Enter commands in R (or R studio, if installed)
install.packages('Seurat')
library(Seurat)
# ==============================================================================
# Morphometric Analysis for Parascaptor
# ==============================================================================
# This script performs Principal Component Analysis (PCA) and Canonical Variate
# Analysis (CVA) on craniomandibular morphometric data for Parascaptor species.
# ==============================================================================
# Load required libraries
library(dplyr) # Data manipulation
library(ggplot2) # Data visualization
library(readxl) # Reading Excel files
library(Morpho) # Morphometric analysis tools
library(MASS) # For Linear Discriminant Analysis (lda)
library(tidyr) # For data tidying (unnest function)
# ==============================================================================
# PRINCIPAL COMPONENT ANALYSIS (PCA)
# ==============================================================================
# Set work folder
setwd("/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/Hidden-diversity-talpid-moles_supplemnt-material/measurement-based_morphometrics")
# Read the morphometric data from Excel file (log10 transformed data)
parascaptor <- read_excel("./para_log10.xlsx")
# Extract morphometric variables (columns 2-16)
data <- parascaptor[, 2:16]
# Extract species names (first column)
species_names <- parascaptor[[1]]
# Perform PCA with scaling (standardization)
pca_result <- prcomp(data, scale. = TRUE)
# Extract PCA scores and add species information
pca_scores <- as.data.frame(pca_result$x)
pca_scores$species <- species_names
# Define color palette for species visualization
palette <- c("#636EFA", "#EF553B", "#00CC96")
# Calculate convex hull for each species group
pca_hull_data <- pca_scores %>%
group_by(species) %>%
do(hull = .[chull(.$PC1, .$PC2), ])
# Combine hull data into a single data frame
pca_hull_data <- bind_rows(pca_hull_data$hull)
# Create PCA plot with convex hulls
pca_plot <- ggplot(pca_scores, aes(x = PC1, y = PC2, color = species)) +
geom_point(size = 3) +
geom_polygon(
data = pca_hull_data,
aes(x = PC1, y = PC2, group = species, fill = species),
alpha = 0.2, color = NA
) +
scale_color_manual(values = palette) +
scale_fill_manual(values = palette) +
theme_minimal() +
labs(
title = expression("PCA of " * italic("Parascaptor") * " species - craniomandibular variables"),
x = "Principal Component 1",
y = "Principal Component 2"
) +
theme(
plot.title = element_text(size = 22, hjust = 0.5),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
axis.text = element_text(size = 13),
legend.text = element_text(size = 17)
)
# Display the PCA plot
print(pca_plot)
# Save PCA plot as PDF file
ggsave("./PCA_Parascaptor.pdf", plot = pca_plot, width = 12, height = 8)
# ==============================================================================
# CANONICAL VARIATE ANALYSIS (CVA)
# ==============================================================================
# Read the morphometric data (same dataset as PCA)
parascaptor <- read_excel("./para_log10.xlsx")
data <- parascaptor[, 2:16]
species_names <- parascaptor[[1]]
# Perform PCA as a preprocessing step for CVA
pca_result <- prcomp(data, scale. = TRUE)
# Extract shape data (all PCs except the first one)
shape_data <- pca_result$x[, -1]
# Perform Linear Discriminant Analysis (LDA) for CVA
cva_results <- lda(shape_data, grouping = species_names)
# Extract CVA scores from the LDA results
cva_scores <- predict(cva_results)$x
# Create data frame for ggplot visualization
df <- data.frame(
CV1 = cva_scores[, 1],
CV2 = cva_scores[, 2],
species = species_names
)
# Define color palette for species visualization (same as PCA)
palette <- c("#636EFA", "#EF553B", "#00CC96")
# Calculate convex hull for each species group in CVA space
# This creates a polygon around each species cluster
hull_data <- df %>%
group_by(species) %>%
do(hull = .[chull(.$CV1, .$CV2), c("CV1", "CV2")]) %>%
unnest(cols = c(hull))
# Create CVA plot with convex hulls
cva_plot <- ggplot(df, aes(x = CV1, y = CV2, color = species)) +
geom_point(size = 3, alpha = 0.8) +
geom_polygon(
data = hull_data,
aes(x = CV1, y = CV2, group = species, fill = species),
alpha = 0.2, color = NA
) +
scale_color_manual(values = palette) +
scale_fill_manual(values = palette) +
theme_minimal() +
labs(
title = expression("CVA of " * italic("Parascaptor") * " species - craniomandibular variables"),
x = "Canonical Variate 1",
y = "Canonical Variate 2"
) +
theme(
plot.title = element_text(size = 22, hjust = 0.5),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
axis.text = element_text(size = 13),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)
)
# Display the CVA plot
print(cva_plot)
# Save CVA plot as PDF file
ggsave("./CVA_Parascaptor.pdf", plot = cva_plot, width = 12, height = 8)
# ==============================================================================
# Morphometric Analysis for Parascaptor
# ==============================================================================
# This script performs Principal Component Analysis (PCA) and Canonical Variate
# Analysis (CVA) on craniomandibular morphometric data for Parascaptor species.
# ==============================================================================
# Load required libraries
library(dplyr) # Data manipulation
library(ggplot2) # Data visualization
library(readxl) # Reading Excel files
library(Morpho) # Morphometric analysis tools
library(MASS) # For Linear Discriminant Analysis (lda)
library(tidyr) # For data tidying (unnest function)
# ==============================================================================
# PRINCIPAL COMPONENT ANALYSIS (PCA)
# ==============================================================================
# Set work folder
setwd("/Users/anlong/Documents/同步空间/Project_Code/Project/mole_project/Hidden-diversity-talpid-moles_supplemnt-material/measurement-based_morphometrics")
# Read the morphometric data from Excel file (log10 transformed data)
euroscaptor <- read_excel("./euroscaptor_log10.xlsx")
# Extract morphometric variables (columns 2-16)
data <- euroscaptor[, 2:16]
# Extract species names (first column)
species_names <- euroscaptor[[1]]
# Perform PCA with scaling (standardization)
pca_result <- prcomp(data, scale. = TRUE)
# Extract PCA scores and add species information
pca_scores <- as.data.frame(pca_result$x)
pca_scores$species <- species_names
# Define color palette for species visualization
palette <- c("#636EFA", "#EF553B", "#00CC96")
# Calculate convex hull for each species group
pca_hull_data <- pca_scores %>%
group_by(species) %>%
do(hull = .[chull(.$PC1, .$PC2), ])
# Combine hull data into a single data frame
pca_hull_data <- bind_rows(pca_hull_data$hull)
# Create PCA plot with convex hulls
pca_plot <- ggplot(pca_scores, aes(x = PC1, y = PC2, color = species)) +
geom_point(size = 3) +
geom_polygon(
data = pca_hull_data,
aes(x = PC1, y = PC2, group = species, fill = species),
alpha = 0.2, color = NA
) +
scale_color_manual(values = palette) +
scale_fill_manual(values = palette) +
theme_minimal() +
labs(
title = expression("PCA of " * italic("Euroscaptor") * " species - craniomandibular variables"),
x = "Principal Component 1",
y = "Principal Component 2"
) +
theme(
plot.title = element_text(size = 22, hjust = 0.5),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
axis.text = element_text(size = 13),
legend.text = element_text(size = 17)
)
# Display the PCA plot
print(pca_plot)
rlang::last_trace()
rlang::last_trace(drop = FALSE)
rlang::last_trace()
rlang::last_trace(drop = FALSE)
